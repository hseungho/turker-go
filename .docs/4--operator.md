# 연산자

## 산술 연산자
|      구분      | 연산자 |    연산     |     피연산자 타입      |
|:------------:|:---:|:---------:|:----------------:|
| 사칙연산, 나머지 연산 |  +  |    덧셈     | 정수, 실수, 복소수, 문자열 |
|              |  -  |    뺄셈     |   정수, 실수, 복소수    |
|              |  *  |    곱셉     |   정수, 실수, 복소수    |
|              |  /  |    나눗셈    |   정수, 실수, 복소수    |
|              |  %  |    나머지    |        정수        |
|    비트 연산     |  &  | AND 비트 연산 |        정수        |
|              | \|  | OR 비트 연산  |        정수        |
|              |  ^  | XOR 비트 연산 |        정수        |
|              | &^  |  비트 클리어   |        정수        |
|    시프트 연산    | <<  |  왼쪽 시프트   |   정수 << 양의 정수    |
|              | \>> |  오른쪽 시프트  |   정수 >> 양의 정수    |

### 연산의 결과 타입
Go 언어에서 모든 연산자의 각 항의 타입은 항상 같아야 한다(시프트 연산 제외). 정수 타입과 실수 타입은 서로 더하거나 
뺄 수 없다. 반드시 타입 변환을 통해 타입을 같도록 맞춰준 다음에 연산해야 한다.

[> 코드로 가기](../ch6/ex6.1/ex6.1.go)

## 비트 연산자
`&, |, ^, &^`는 비트 단위로 연산하는 비트 연산자이다. 비트 연산은 정수만 피연산자가 될 수 있다.

비트 연산을 위해서는 먼저 정숫값을 2진수로 표현한 뒤 게산해야 한다. 

### & AND 연산  
`&` AND 연산은 A와 B 모두 1인 비트만 1이 된다.

| A | B | A & B |
|:-:|:-:|:-----:|
| 0 | 0 |   0   |
| 1 | 0 |   0   |
| 0 | 1 |   0   |
| 1 | 1 |   1   |

### | OR 연산  
`|` OR 연산은 A와 B 중 하나라도 1이면 1이 된다.

| A | B | A \| B |
|:-:|:-:|:------:|
| 0 | 0 |   0    |
| 1 | 0 |   1    |
| 0 | 1 |   1    |
| 1 | 1 |   1    |

### ^ XOR 연산  
`^` XOR 연산은 A와 B가 다르면 1이 된다. `^` 연산은 `^A`처럼 단독으로 사용할 수도 있다. 단독으로 사용할 경우,
비트 반전을 한다(1은 0으로, 0은 1로).

| A | B | A ^ B |
|:-:|:-:|:-----:|
| 0 | 0 |   0   |
| 1 | 0 |   1   |
| 0 | 1 |   1   |
| 1 | 1 |   0   |

[> 코드로 가기(비트반전)](../ch6/ex6.2/ex6.2.go)

### &^ 비트 클리어 연산
`&^` 비트 클리어 연산은 특정 비트를 0으로 바꾸는 연산이다. 우변값에 해당하는 비트를 클리어한다. `^`를 먼저 수행하고
`&`를 수행한다.

예를 들어, `10 &^ 2` 연산 과정은 다음과 같다.
> 1. ^ 연산을 수행
>    1. 0000 0010 <- 2
>    2. 1111 1101 <- ^2
> 2. & 연산을 수행
>    1. 0000 1010 <- 10
>    2. 1111 1101 <- ^2
>    3. 0000 1000 <- 10 &^ 2

최종 연산값은 `0000 1000`이 된다. 10의 2진수인 `0000 1010`과 비교해보면, 2번째 비트만 0으로 바뀌었다. 이처럼 
`&^` 비트 클리어 연산자는 특정 비트만 0으로 바꾸고 싶을 때 사용한다.

## 시프트 연산자
비트를 왼쪽 또는 오른쪽으로 밀거나 당기는 연산자다. << 왼쪽 시프트와 >> 오른쪽 시프트를 지원한다.

### << 왼쪽 시프트  
오른쪽 피연산자값만큼 전체 비트를 왼쪽으로 밀어낸다. 이 때, 비트가 이동되어 **빈 자리는 0이 채워지고**, **자릿수를 벗어난 
비트는 버려진다**. 비트 수를 나타내는 오른쪽 피연산자는 **반드시 양의 정수**여야 한다. 만일 오른쪽 피연산자가 **음의 값을 
가지는 변수이면 프로그램이 비정상 종료**된다.

[> 코드로 가기](../ch6/ex6.3/ex6.3.go)

### \>> 오른쪽 시프트  
비트값을 오른쪽으로 밀어낸다. 밀어내는 비트 수를 나타내는 오른쪽 피연산자는 반드시 양의 정수여야 한다. 왼쪽에 추가되는 
비트는 **최상위 비트값과 같은 비트값이 추가**된다. 즉 **부호 있는 정수이면 왼쪽 비트에 부호와 같은 값**으로, **부호 없는 정수이면 
0으로 채워진다**. **음수라면 최상위 비트가 1이므로 1로, 양수면 0으로 채워진다**.

[> 코드로 가기](../ch6/ex6.4/ex6.4.go)

## 비교 연산자
양변을 비교하여 조건에 만족하면 불리언 값 true를, 만족하지 못하면 false를 반환하는 연산자다. `==, !=, <, >, <=, >=`를 지원한다.

비교 연산자를 사용할 때 몇 가지 주의할 점이 있다. 부호 있는 정수를 사용할 때 발생하는 오버플로와 언더플로 문제, 
실수끼리의 비교다.

### 정수 오버플로
정수가 정수 타입의 범위를 벗어난 경우 값이 비정상으로 변화하는 현상을 오버플로overflow라고 한다. 
그래서 x가 정수 타입일 때 `x < x + 1`을 항상 만족하지 못할 수 있다.

[> 코드로 가기](../ch6/ex6.5/ex6.5.go)

### 정수 언더플로  
정수 타입이 표현할 수 있는 가장 작은 값에서 -1을 했을 때는 가장 큰값으로 바뀌는 현상을 언더플로underflow라고 한다. 
예를 들어, int8 타입에서 `-128 - 1`을 하면 `-129`가 아니라 `127`이 된다. 즉, 8비트 정수 타입에서 
`-128 > -128-1`은 false가 된다.

> 정수 타입은 값의 경계에서 오버플로와 언더플로가 발생하기 때문에 연산할 때 항상 경계값에 주의하여야 한다.

### float 비교 연산  
실수끼리의 == 연산에서는 예기치 않은 결과가 나올 때가 있다.
```go
package main

import "fmt"

func main() {
  var a float64 = 0.1
  var b float64 = 0.2
  var c float64 = 0.3
  	
  fmt.Printf("%f + %f == %f : %v\n", a, b, c, a + b == c)
  fmt.Println(a + b)
}
```
출력 결과
```text
0.100000 + 0.200000 == 0.300000 : false
0.30000000000000004
```
이는 float64 표현 방식으로 생긴 오차 때문이다.

[> 코드로 가기](../ch6/ex6.6/ex6.6.go)

### 실수 오차
> 컴퓨터에서 실숫값을 표현하기 위해 지수부와 소수부로 나눠서 표현한다. 컴퓨터는 지수부와 소수부가 10진수 기준이 아니라 
> 2진수 기준으로 되어 있다. 그래서 10진수 실수를 정확히 표현하기 어려운 문제가 있다.
> 
> 예를 들어, 0.375는 0.3 + 0.07 + 0.005다. 이는 곧, (3x10^-1) + (7x10^-2) + (5x10^-3)이다. 하지만 컴퓨터는
> 2진수를 사용하기 때문에, 2^-n으로 소수를 표현한다. 2^-1은 0.5이며, 2^-2는 0.25, 2^-3은 0.125가 된다.
> 즉 0.375를 2진수로 나타내면 (1x2^-2) + (1x2^-3)다. 하지만 대부분의 소수점 이하 숫자들은 2의 음수 승수로 표현하기 어렵다.
> 0.376만 하더라도, 아무리 작은 2의 음수 승수값을 더해도 0.376이라는 값은 나오지 않는다. 
> 
> 그래서 0.376은 float32 타입으로 최대한 가깝게 표현한 값이 0.375999987125396728515625로 표현하기 때문에 
> 오차가 발생할 수밖에 없다.
> 
> 0.3 또한 2진수 체계로는 정확한 실숫값을 표현하기 어렵기 때문에, 0.1 + 0.2 != 0.3이 되는 것이다.

**작은 오차 무시하기**  
실숫값을 정확히 표현할 수 없기 때문에 오차가 발생할 수밖에 없다. 그래서 아주 작은 오차는 무시하는 방법으로 
값을 비교할 수 있다.
```go
package main

import "fmt"

const epsilon = 0.000001

func equals(a, b float64) bool {
  if a > b {
    if a-b <= epsilon {
      return true
    } else {
      return false
    }
  } else {
    if b-a <= epsilon {
      return true
    } else {
      return false
    }
  }
}

func main() {
  var a float64 = 0.1
  var b float64 = 0.2
  var c float64 = 0.3

  fmt.Printf("%0.18f + %0.18f = %0.18f\n", a, b, a+b)
  fmt.Printf("%0.18f == %0.18f : %v\n", c, a+b, equals(c, a+b))
  /*
  0.100000000000000006 + 0.200000000000000011 = 0.300000000000000044
  0.299999999999999989 == 0.300000000000000044 : true
  */

  a = 0.0000000000004
  b = 0.0000000000002
  c = 0.0000000000007

  fmt.Printf("%g == %g : %v\n", c, a+b, equals(c, a+b))
  /*
  7e-13 == 6.000000000000001e-13 : true
  실제로는 비교값이 다름에도 같다고 나오는 문제가 발생
  */
}
```
[> 코드로 가기](../ch6/ex6.7/ex6.7.go)

**오차를 없애는 더 나은 방법**  
`epsilon`으로 비교하는 건 더 작은 실숫값에 대해서는 대응할 수 없다. 이는 비교 대상이 상대적이기 때문에, 
정확하고 절대적인 `epsilon`값을 설정하기 어렵다.

가장 간편하고 좋은 방법은 1비트 차이만큼 비교하는 것이다. 실수 표현은 지수부와 소수부로 나눠지기 때문에 지수부 표현에서
가장 작은 차이는 가장 오른쪽 비트값 하나만큼이다.

0.3은 float32 타입에서 표현할 때, 근사치값 두 개(0.3보다 작은 근사치값, 0.3보다 큰 근사치값) 중 하나로 표현해야 한다.
둘 다 0.3과 정확히 같지는 않지만 결국 한 근사치값은 0.3보다 아주 작고, 다른 한 근사치값은 0.3보다 아주 조금 크다. 그리고
두 값의 비트 차이는 가장 마지막 비트 차이 밖에 나지 않는다.
```
0 01111101 00110011001100110011001 <- 0.2999999821186065673828125
0 01111101 00110011001100110011010 <- 0.300000011920928955078125
```
즉 0.3을 표현할 수 있는 값의 실수 타입 범위에서 가장 작은 차이이기 때문에, 어떤 값이 이 두 값 사이라면
0.3과 같다고 간주하는 것이다.

이를 Go언어에서는 math 패키지에서 `Nextafter()` 함수로 제공해주고 있다.
```go
func Nextafter(x, y float64) (r float64)
```
이 함수는 float64 타입 두 개를 받아 float64 타입 하나를 반환한다. 함수 동작은 x에서 y를 향해 1비트만큼 
조정한 값을 반환한다. 만약 x가 y보다 작다면 x에서 1비트만큼 증가시키고 그렇지 않다면 x에서 1비트만큼 감소시킨 값을 반환한다.

즉, 가장 작은 오차만큼을 y를 향해 더하거나 빼주는 것이다. 이 함수를 이용하여 실숫값 대소 비교를 할 수 있다.
```go
package main

import (
  "fmt"
  "math"
)

func equals(a, b float64) bool {
  return math.Nextafter(a, b) == b
}

func main() {
  var a float64 = 0.1
  var b float64 = 0.2
  var c float64 = 0.3

  fmt.Printf("%0.18f + %0.18f = %0.18f\n", a, b, a+b)
  fmt.Printf("%0.18f == %0.18f : %v\n", c, a+b, equals(c, a+b))
  /*
  0.100000000000000006 + 0.200000000000000011 = 0.300000000000000044
  0.299999999999999989 == 0.300000000000000044 : true
  */

  a = 0.0000000000004
  b = 0.0000000000002
  c = 0.0000000000007

  fmt.Printf("%g == %g : %v\n", c, a+b, equals(c, a+b))
  /*
  7e-13 == 6.000000000000001e-13 : false
   */
}
```
[> 코드로 가기](../ch6/ex6.8/ex6.8.go)

하지만 이 또한 오차를 무시하는 방법이다. 오차가 매우 작을 뿐이지 정확한 계산은 아니다.

금융프로그램 같이 정밀한 계산이 필요한 프로그램이라면 `math/big` 패키지에서 제공하는 `Float` 객체를 사용해야 한다. 
`Float` 객체를 사용하면 정밀도를 직접 조정할 수 있기 때문에 정밀도를 높여서 더 정확한 수치 계산을 할 수 있다.

[> 코드로 가기](../ch6/ex6.9/ex6.9.go)

## 논리 연산자
논리 연산자는 불리언 피연산자를 대상으로 연산해 결과로 true나 false를 반환한다. `&&, ||, !` 연산자를 지원한다.

### && AND 연산자
|   A   |   B   | A && B |
|:-----:|:-----:|:------:|
| false | false | false  |
| true  | false | false  |
| false | true  |  true  |
| true  | true  |  true  |

### || OR 연산자
|   A   |   B   | A \|\| B |
|:-----:|:-----:|:--------:|
| false | false |  false   |
| true  | false |   true   |
| false | true  |   true   |
| true  | true  |   true   |

### ! NOT 연산자
|   A   |  !A   | 
|:-----:|:-----:|
| false | true  |
| true  | false |

## 대입 연산자
`=` 대입 연산자는 우변값을 좌변(메모리 공간)에 복사한다. 좌변은 반드시 저장할 공간이 있는 변수가 와야 한다.
```go
var a int
a = 10
```
대입 연산자는 아무런 값을 반환하지 않는다.
```go
var a int
var b int
a = b = 10 // 오류가 발생한다
```
`b = 10` 구문은 반환값이 없기 때문에 이를 다시 a에 대입할 수 없다. 위와 같이 동작하려면 두 줄로 나타내야 한다.
```go
var a int
var b int
b = 10
a = b
```

### 복수 대입 연산자
여러 값을 한 번에 대입할 수 있다. 이를 위해 우변 개수에 맞춰서 좌변 변수 개수도 맞춰줘야 한다.  
첫 번째 우변값은 첫 번째 좌변 주소에, 두 번째 우변값은 두 번째 좌변 주소에 대입된다.
```go
a, b = 3, 4
```
이를 사용하여 두 변수의 값을 서로 바꿀 수 있다.
```go
var a = 10
var b = 20

a, b = b, a
```

### 복합 대입 연산자
대입 연산자 앞에 다른 산술 연산자를 붙여서 변수의 값과 연산의 결과를 다시 변수에 대입할 수 있다.
```go
var a = 10
a += 2 // a = a + 2 와 같음
```
복합 대입 연산자 또한 어떠한 값도 반환하지 않는다.
```go
b = a += 2 // 오류가 발생한다
```

### 증감 연산자
변숫값을 1 증가하거나 감소하는 연산자다. `++, --`를 지원한다. 다만 Go언어에서는 전위 증감 연산자는 지원하지 않고, 
후위 증감 연산자만 가능하다. 증감 연산자 또한 어떠한 값도 반환하지 않는다.
```go
var a int = 10
a++
a--
// ++a는 지원 X
```

### 기타 연산자
| 연산자 |               설명               |
|:---:|:------------------------------:|
| [ ] |        배열의 요소에 접근할 때 사용        |
|  .  |     구조체나 패키지 요소에 접근할 때 사용      |
|  &  |        변수의 메모리 주솟값을 반환         |
|  *  | 포인터 변수가 가리키는 메모리 주소에 접근할 때 사용  |
| ... | 슬라이스 요소들에 접근하거나 가변 인수를 만들 때 사용 |
|  :  |       배열의 일부분을 집어올 때 사용        |
| <-  |      채널에서 값을 빼거나 넣을 때 사용       |

## 연산자 우선순위
우선순위가 높은 연산자부터 먼저 계산된다. 우선순위가 같다면 좌측부터 우측으로 연산된다.

| 우선순위 |       연산자        |
|:----:|:----------------:|
|  5   | * / % << >> & &^ |
|  4   |     + - / ^      |
|  3   | == != < <= > >=  |
|  2   |        &&        |
|  1   |       \|\|       |

# 핵심요약
> 1. 산술 연산자로는 사칙 연산, 비트 연산, 시프트 연산이 있다.
> 2. 정수 타입으로 값의 경계에서 연산할 때는 항상 주의해야 한다.
> 3. 실수 타입은 서로 값이 같은지 비교하는 == 연산자가 비정상 동작할 수 있다.
> 4. 비교 연산자와 논리 연산자를 결합하여 다양한 조건을 만들 수 있다.
> 5. 대입 연산자는 값을 반환하지 않는다.
> 6. 복합 대입 연산자를 사용하면 연산을 간편하게 줄여 쓸 수 있다.
