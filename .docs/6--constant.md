# 상수 Constant

상수는 변하지 않는 값을 말한다. 상수는 변수와 달리 초기화된 값을 변경할 수 없다.

## 상수 선언
Go 언어는 primitive 타입만 상수화할 수 있고, complex 타입은 상수화할 수 없다.  

### Go 언어 상수 사용 가능 타입
- 불리언
- 정수
- 복소수
- 룬 rune
- 실수
- 문자열

상수 선언 방식은 변수를 뜻하는 `var` 대신 `const`키워드를 사용하면 된다. 패키지 외부로 공개되는 
상수의 이름은 첫 글자를 대문자로 선언하면 된다.

[> 코드로 가기](../ch8/ex8.1/ex8.1.go)

## 상수의 목적
### 변하면 안 되는 값에 상수 사용
원주율과 같이 고정되어 있는 값은 매번 같은 값을 선언하기도 귀찮고, 실수로 값을 잘못 선언할 수도 있다.
이와 같이 항상 같은 값을 기대할 수 있는 변수를 상수로 선언하면 귀찮음도 해결되고 휴먼 에러도 줄일 수 있어서 안전하고 확실하다.

[> 코드로 가기](../ch8/ex8.2/ex8.2.go)

### 코드값으로 사용
상수를 코드값으로 사용하 수도 있다. `코드값`이란 어떤 숫자에 의미를 부여하는 것을 말한다.
예를 들어, ASCII 문자 코드에서 `A`는 `65`다. 65와 A 사이에 어떠한 개연성도 있지 않지만 `A`를 표현하는
숫자로 `65`를 사용하기로 약속한 것이다. 마찬가지로 HTTP 프로토콜의 응답코드 200번은 `OK`를 의미하고
404번은 `NOT_FOUND`라는 의미를 부여한 것이다.

돼지, 소, 닭 등 동물을 나타내야 하는 경우 매번 `"Pig", "Cow", "Chicken"`과 같이 문자열로 나타내면 
번거롭기도 하고 스펠링을 틀리는 등 실수가 발생하기도 하며, 문자열 처리가 숫자값보다 성능이나 메모리에 더 안 좋은 
문제가 있다. 그래서 각각 Pig를 1번, Cow를 2번, Chicken을 3번이라는 의미를 부여하여 약속을 정해두면 실수를 방지하고
성능도 개선할 수 있다.

[> 코드로 가기](../ch8/ex8.3/ex8.3.go)

### `iota`로 간편하게 열거값 사용
코드값으로 사용하기 때문에 값이 그냥 1,2,3,..처럼 1씩 증가하도록 정의할 때는 `iota` 키워드를 사용하면 보다 편리하다.
예를 들어, 빨강, 파랑, 초록 세가지 색에 숫자 코드를 부여하기 때문에 어떤 숫자가 사용되는지는 의미 없다. 그래서 첫 상수부터 
0부터 시작하여 1씩 증가하도록 하는 `iota` 키워드가 유용하다. `iota`는 소괄호를 벗어나면 다시 초기화된다.
```go
const (
  Red int = iota    // 0
  Blue int = iota   // 1
  Green int = iota  // 2
)
```
```go
const (
  C1 uint = iota + 1 // 1 = 0 + 1
  C2                 // 2 = 1 + 1
  C3                 // 3 = 2 + 1
)
```
```go
const (
  BitFlag1 uint = i << iota // 1 = 1 << 0
  BitFlag2                  // 2 = 1 << 0
  BitFlag3                  // 4 = 1 << 2
  BitFlag4                  // 8 = 1 << 3 
)

const (
  A int = iota // 0
  B            // 1
)
```

## 타입 없는 상수
상수 선언 시 타입을 명시하지 않으면 타입 없는 상수가 된다. 타입 없는 상수는 타입이 정해지지 않은 상태로 사용된다.
타입 없는 상수는 변수에 복사될 때 타입이 정해지기 때문에 타입 캐스팅을 별도로 하지 않아도 되지만, 타입 있는 상수는
타입이 정해진 상태로 초기화되기 때문에 동일한 타입과의 연산만 가능하다. 또한 상수는 타입 캐스팅이 불가능하다.

타입 없는 상수는 변수에 복사될 때 타입이 정해지는 특징 때문에 여러 타입에 사용되는 상숫값을 사용할 때 편리하다.

[> 코드로 가기](../ch8/ex8.4/ex8.4.go)

## 상수와 리터럴
컴퓨터에서 리터럴이란 고정된 값, 값 그 자체로 쓰이는 문구라고 볼 수 있다.
```go
var str string = "Hello World"
var i int = 0
i = 30
```
위 코드에서 `"Hello World", 0, 30`과 같이 고정된 값 그 자체로 쓰이는 문구가 리터럴이다. Go 언어에서 상수는 
리터럴과 같이 취급된다. 그래서 컴파일될 때 상수는 리터럴로 변환되어 실행파일에 작성된다.

상수 표현식 역시 컴파일 타임에 실제 결괏값 리터럴로 변환하기 때문에 상수 표현식 계산에 CPU 자원을 사용하지 않는다.
```go
const PI = 3.14
var a int = PI * 100
```
위 코드가 컴파일 타임에는 아래와 같이 변환된다.
```go
var a int = 314
```
상수의 메모리 주소값(`&PI`)에 접근할 수 없는 이유 역시 컴파일 타임에 리터럴로 변환되어 실행파일에 값 형태로 작성되기 때문이다. 그래서 상수는
`동적 할당 메모리 영역`을 사용하지 않는다.

## 핵심 요약
> 1. 상수는 변하지 않는 값이다.
> 2. 자주 쓰는 고정값에 이름을 부여해서 편리하게 사용할 수 있다.
> 3. 상수를 코드값으로 사용할 수 있다.
> 4. iota를 사용하면 증가하는 상수를 편리하게 선언할 수 있다.
> 5. 타입 없는 상수를 선언하면 타입이 다른 여러 변수에서 사용할 수 있다.
